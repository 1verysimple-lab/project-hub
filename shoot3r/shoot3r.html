<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Pulse v10: Terminator</title>
    <style>
        body {
            background-color: #050505;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 5px;
            height: 100dvh;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        
        h1 { margin: 5px 0; font-size: 1rem; text-transform: uppercase; letter-spacing: 2px; }
        
        #status {
            height: 30px;
            text-align: center;
            font-size: 0.8rem;
            margin-bottom: 5px;
            color: #fff;
            font-weight: bold;
        }

        #instructions {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 10px;
        }

        /* The Grid */
        #game-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 1px;
            width: 95vw;
            max-width: 450px;
            aspect-ratio: 1 / 1;
            margin-bottom: 15px;
            border: 1px solid #333;
            background-color: #000;
        }

        .cell {
            border-radius: 1px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            line-height: 1;
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        /* Terrain */
        .floor { background-color: #1a1a1a; }
        .building { background-color: #444; border: 1px solid #555; } 
        
        /* Units */
        .player { color: #00ff41; text-shadow: 0 0 5px #00ff41; font-size: 1rem; font-weight: bold; z-index: 10; }
        .enemy { color: #ff003c; text-shadow: 0 0 5px #ff003c; font-size: 1rem; font-weight: bold; z-index: 10; }
        
        /* Traces */
        .trace-p::after { content: '•'; color: #004411; font-size: 1.2rem; position: absolute; }
        .trace-e::after { content: '•'; color: #440011; font-size: 1.2rem; position: absolute; }
        .trace-mix::after { content: '•'; color: #444400; font-size: 1.2rem; position: absolute; }

        /* Pulse */
        body.pulse-active { box-shadow: inset 0 0 50px rgba(0, 255, 65, 0.1); }
        .pulse-active #game-board { border-color: #00ff41; }
        
        /* Controls */
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            width: 95vw;
            max-width: 350px;
        }

        button {
            background: #222;
            border: 1px solid #444;
            color: #eee;
            padding: 12px;
            font-size: 1rem;
            border-radius: 4px;
            touch-action: manipulation;
        }
        button:active { background: #555; }
        button:disabled { opacity: 0.3; background: #111; border-color: #222; color: #555; }
        .action-btn { background: #440000; border-color: #880000; font-weight: bold; color: #ffcccc; }
        .wait-btn { background: #003300; border-color: #006600; }
        .restart-btn { grid-column: span 3; background: #004466; margin-top: 5px; display: none; }

    </style>
</head>
<body>

    <h1 id="turn-display">TURN 1 | DARK</h1>
    <div id="status">Hunting...</div>
    <div id="instructions">ARROWS: Move | SPACE: Shoot | B: Knife</div>
    
    <div id="game-board"></div>

    <div id="controls">
        <button id="btn-shoot" class="action-btn" onclick="tryShoot()">SHOOT</button>
        <button onclick="movePlayer(0, -1)">▲</button>
        <button class="action-btn" onclick="tryKnife()">KNIFE</button>
        
        <button onclick="movePlayer(-1, 0)">◀</button>
        <button class="wait-btn" onclick="endTurn()">WAIT</button>
        <button onclick="movePlayer(1, 0)">▶</button>
        
        <button></button>
        <button onclick="movePlayer(0, 1)">▼</button>
        <button></button>
        
        <button id="restart-btn" class="restart-btn" onclick="initGame()">NEW MAP (N)</button>
    </div>

<script>
    const GRID_SIZE = 15;
    const PULSE_FREQ = 3;
    const T_FLOOR = 0, T_BUILDING = 1;

    let map = []; 
    let playerPos, enemyPos;
    let aiLastKnownTarget = null; 
    let aiState = "PATROL"; 

    let turn = 1;
    let gameOver = false;
    let reloadTimer = 0;
    let historyP = [], historyE = [];
    
    const boardEl = document.getElementById('game-board');
    const statusEl = document.getElementById('status');
    const turnEl = document.getElementById('turn-display');
    const restartBtn = document.getElementById('restart-btn');
    const btnShoot = document.getElementById('btn-shoot');
    const bodyEl = document.body;

    // --- KEYBOARD CONTROLS ---
    document.addEventListener('keydown', (e) => {
        if (gameOver && (e.key === 'n' || e.key === 'N')) {
            initGame();
            return;
        }
        if (gameOver) return;

        switch(e.key) {
            case "ArrowUp": movePlayer(0, -1); break;
            case "ArrowDown": movePlayer(0, 1); break;
            case "ArrowLeft": movePlayer(-1, 0); break;
            case "ArrowRight": movePlayer(1, 0); break;
            case " ": e.preventDefault(); tryShoot(); break; // Space
            case "b": 
            case "B": tryKnife(); break;
        }
    });

    function initGame() {
        gameOver = false;
        turn = 1;
        reloadTimer = 0;
        historyP = [];
        historyE = [];
        aiLastKnownTarget = null;
        aiState = "PATROL";
        
        restartBtn.style.display = 'none';
        btnShoot.disabled = false;
        btnShoot.innerText = "SHOOT";
        statusEl.innerText = "Enemy Speed: 2x";
        statusEl.style.color = "#fff";
        
        generateCity();
        recordHistory();
        render();
    }

    function recordHistory() {
        historyP.push({x: playerPos.x, y: playerPos.y});
        historyE.push({x: enemyPos.x, y: enemyPos.y});
    }

    function generateCity() {
        map = [];
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) row.push(T_BUILDING);
            map.push(row);
        }
        let blockSize = 3; 
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (x % blockSize === 0 || y % blockSize === 0) map[y][x] = T_FLOOR;
                if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) map[y][x] = T_FLOOR;
            }
        }
        for (let i = 0; i < 20; i++) {
            let rx = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
            let ry = Math.floor(Math.random() * (GRID_SIZE - 2)) + 1;
            map[ry][rx] = T_FLOOR;
        }
        playerPos = findSpawn();
        enemyPos = findSpawn();
        while(getDist() < 8) { enemyPos = findSpawn(); } 
    }

    function findSpawn() {
        let x, y;
        do {
            x = Math.floor(Math.random() * GRID_SIZE);
            y = Math.floor(Math.random() * GRID_SIZE);
        } while (map[y][x] === T_BUILDING);
        return {x, y};
    }

    function movePlayer(dx, dy) {
        if (gameOver) return;
        const newX = playerPos.x + dx;
        const newY = playerPos.y + dy;

        if (isValidMove(newX, newY)) {
            playerPos = {x: newX, y: newY};
            if (checkCollision()) return;
            endTurn();
        }
    }

    function isValidMove(x, y) {
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
        let t = map[y][x];
        if (t === T_BUILDING) return false;
        return true;
    }

    function endTurn() {
        if (gameOver) return;
        
        if (reloadTimer > 0) {
            reloadTimer--;
            if(reloadTimer === 0) {
                btnShoot.disabled = false;
                btnShoot.innerText = "SHOOT";
                statusEl.innerText = "Ready to fire.";
            } else {
                statusEl.innerText = "Reloading... (" + reloadTimer + ")";
                btnShoot.innerText = "JAMMED";
            }
        }

        executeAITurn();
    }

    async function executeAITurn() {
        // --- MOVE 1 ---
        // Check shot BEFORE moving
        if (tryAIKillShot()) return;
        
        // Execute Move 1
        performAIMovement();
        
        // Check shot AFTER moving
        if (tryAIKillShot()) return;

        if (checkCollision()) return;

        // --- MOVE 2 (Delay for effect, but fast) ---
        await new Promise(r => setTimeout(r, 50));
        if (gameOver) return;

        performAIMovement();
        
        // Check shot AFTER second move
        if (tryAIKillShot()) return;

        if (checkCollision()) return;

        if (!gameOver) {
            recordHistory();
            turn++;
            render();
        }
    }

    // --- KILL LOGIC ---
    function tryAIKillShot() {
        const isPulse = (turn % PULSE_FREQ === 0);
        const canSee = hasClearShot(enemyPos, playerPos); // Line of Sight
        
        // Kill if: Pulse is active OR Player is exposed (straight line)
        if ((isPulse || canSee) && canSee) {
            endGame(false, "SNIPED! The AI caught you in the open.");
            return true;
        }
        
        if (getDist() <= 1.5) {
             endGame(false, "STABBED! AI ran you down.");
             return true;
        }
        return false;
    }

    // --- MOVEMENT LOGIC ---
    function performAIMovement() {
        const isPulse = (turn % PULSE_FREQ === 0);
        const nextIsPulse = ((turn + 1) % PULSE_FREQ === 0);

        // Update Memory
        if (isPulse || hasClearShot(playerPos, enemyPos)) {
            aiLastKnownTarget = {x: playerPos.x, y: playerPos.y};
            aiState = "HUNT";
        }

        // Defensive Move?
        if (nextIsPulse) {
            if (aiSeekCover()) return;
        }

        // Offensive Move
        if (aiState === "HUNT" && aiLastKnownTarget) {
            if (enemyPos.x === aiLastKnownTarget.x && enemyPos.y === aiLastKnownTarget.y) {
                aiState = "PATROL"; 
                aiLastKnownTarget = null;
                aiPatrol();
            } else {
                aiMoveTowards(aiLastKnownTarget);
            }
        } else {
            aiPatrol();
        }
    }

    function aiMoveTowards(target) {
        let dx = 0, dy = 0;
        if (enemyPos.x < target.x) dx = 1; else if (enemyPos.x > target.x) dx = -1;
        if (enemyPos.y < target.y) dy = 1; else if (enemyPos.y > target.y) dy = -1;

        let moveX = (Math.abs(enemyPos.x - target.x) > Math.abs(enemyPos.y - target.y));
        let moved = false;
        
        if (moveX) {
            if (trySmartMove(dx, 0)) moved = true;
            else if (trySmartMove(0, dy)) moved = true;
        } else {
            if (trySmartMove(0, dy)) moved = true;
            else if (trySmartMove(dx, 0)) moved = true;
        }
        
        if (!moved) {
            trySmartMove(1,0, true) || trySmartMove(-1,0, true) || trySmartMove(0,1, true) || trySmartMove(0,-1, true);
        }
    }

    function aiPatrol() {
        let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        let move = dirs[Math.floor(Math.random()*dirs.length)];
        trySmartMove(move[0], move[1], true);
    }

    function aiSeekCover() {
        let dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        dirs.sort(() => Math.random() - 0.5);

        for (let d of dirs) {
            let nx = enemyPos.x + d[0];
            let ny = enemyPos.y + d[1];
            
            if (isValidMove(nx, ny)) {
                if (aiLastKnownTarget) {
                    // Check if this new spot is hidden from the last known target pos
                    if (!hasClearShot({x:nx, y:ny}, aiLastKnownTarget)) {
                        enemyPos.x = nx; enemyPos.y = ny;
                        return true;
                    }
                }
            }
        }
        return false; 
    }

    function trySmartMove(dx, dy, ignoreSafety = false) {
        if (dx === 0 && dy === 0) return false;
        let nx = enemyPos.x + dx;
        let ny = enemyPos.y + dy;
        
        if (!isValidMove(nx, ny)) return false;

        // Safety: Don't walk INTO a firing line if you know where player is
        if (!ignoreSafety && aiLastKnownTarget) {
             if (hasClearShot({x:nx, y:ny}, aiLastKnownTarget)) {
                 return false; 
             }
        }
        enemyPos.x = nx;
        enemyPos.y = ny;
        return true;
    }

    function tryShoot() {
        if (gameOver || reloadTimer > 0) return;
        const isPulse = (turn % PULSE_FREQ === 0);
        const canSee = hasClearShot(playerPos, enemyPos);

        reloadTimer = 2; 
        btnShoot.disabled = true;
        btnShoot.innerText = "FIRING";
        
        aiLastKnownTarget = {x: playerPos.x, y: playerPos.y}; 
        aiState = "HUNT";

        if (isPulse || canSee) {
            if (canSee) {
                endGame(true, "HEADSHOT! Target eliminated.");
            } else {
                statusEl.innerText = "BLOCKED! You hit a wall.";
                endTurn(); 
            }
        } else {
            statusEl.innerText = "BLIND FIRE! AI knows where you are.";
            endTurn();
        }
    }

    function tryKnife() {
        if (gameOver) return;
        if (getDist() <= 1.5) {
            endGame(true, "EXECUTED! Clean kill.");
        } else {
            statusEl.innerText = "Missed the stab!";
            endTurn();
        }
    }

    function checkCollision() {
        if (playerPos.x === enemyPos.x && playerPos.y === enemyPos.y) {
            endGame(false, "COLLISION! He ran you down.");
            return true;
        }
        return false;
    }

    function endGame(win, msg) {
        recordHistory();
        gameOver = true;
        statusEl.innerText = msg;
        statusEl.style.color = win ? "#00ff41" : "#ff003c";
        restartBtn.style.display = 'block';
        render(); 
    }

    function getDist() {
        return Math.sqrt(Math.pow(playerPos.x - enemyPos.x, 2) + Math.pow(playerPos.y - enemyPos.y, 2));
    }

    function hasClearShot(p1, p2) {
        // Must share X or Y (Straight line only)
        if (p1.x !== p2.x && p1.y !== p2.y) return false;

        let x0 = p1.x, y0 = p1.y;
        let x1 = p2.x, y1 = p2.y;
        let dx = Math.abs(x1 - x0);
        let dy = Math.abs(y1 - y0);
        let sx = (x0 < x1) ? 1 : -1;
        let sy = (y0 < y1) ? 1 : -1;
        let err = dx - dy;
        while (true) {
            if (`${x0},${y0}` !== `${p1.x},${p1.y}` && `${x0},${y0}` !== `${p2.x},${p2.y}`) {
                 let t = map[y0][x0];
                 if (t === T_BUILDING) return false; 
            }
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
        }
        return true;
    }

    function render() {
        boardEl.innerHTML = '';
        const isPulse = (turn % PULSE_FREQ === 0);
        const isExposed = hasClearShot(playerPos, enemyPos);

        if (isPulse) {
            bodyEl.classList.add('pulse-active');
            turnEl.innerText = `TURN ${turn} | PULSE`;
            turnEl.style.color = "#fff";
        } else {
            bodyEl.classList.remove('pulse-active');
            turnEl.innerText = `TURN ${turn} | DARK`;
            turnEl.style.color = "#00ff41";
        }
        
        if (reloadTimer > 0 && !gameOver) {
             turnEl.innerText += " (JAMMED)";
             turnEl.style.color = "#ffaa00";
        }

        if (isExposed && !gameOver) {
            statusEl.innerText = "WARNING: LINE OF FIRE!";
            statusEl.style.color = "#ff003c";
        }

        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                let t = map[y][x];
                if (t === T_BUILDING) cell.classList.add('building');
                else cell.classList.add('floor');

                if (gameOver) {
                    let pHere = historyP.some(pos => pos.x === x && pos.y === y);
                    let eHere = historyE.some(pos => pos.x === x && pos.y === y);
                    if (pHere && eHere) cell.classList.add('trace-mix');
                    else if (pHere) cell.classList.add('trace-p');
                    else if (eHere) cell.classList.add('trace-e');
                }

                if (x === playerPos.x && y === playerPos.y) {
                    cell.innerText = '▲';
                    cell.classList.add('player');
                }
                else if (x === enemyPos.x && y === enemyPos.y) {
                    if (gameOver || isPulse || getDist() <= 1.5 || isExposed) {
                        cell.innerText = '■';
                        cell.classList.add('enemy');
                    }
                }
                boardEl.appendChild(cell);
            }
        }
    }

    initGame();
</script>
</body>
</html>